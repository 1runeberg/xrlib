/* 
 * Copyright 2024,2025 Copyright Rune Berg 
 * https://github.com/1runeberg | http://runeberg.io | https://runeberg.social | https://www.youtube.com/@1RuneBerg
 * Licensed under Apache 2.0: https://www.apache.org/licenses/LICENSE-2.0
 * SPDX-License-Identifier: Apache-2.0
 * 
 * This work is the next iteration of OpenXRProvider (v1, v2)
 * OpenXRProvider (v1): Released 2021 -  https://github.com/1runeberg/OpenXRProvider
 * OpenXRProvider (v2): Released 2022 - https://github.com/1runeberg/OpenXRProvider_v2/
 * v1 & v2 licensed under MIT: https://opensource.org/license/mit
*/

#pragma once

#include <xrlib/session.hpp>
#include <xrlib/interaction_profiles.hpp>

#include <map>
#include <functional>

namespace fnArg = std::placeholders;
namespace xrlib
{
	struct SActionSet;
	struct SAction;

	/// <summary>
	/// Callback function for openxr actions - will be called if actionstate has changed since the last input frame
	/// or is active for pose actions
	/// </summary>
	typedef std::function< void( SAction *, uint32_t ) > Callback_InputAction;

	/// <summary>
	/// Represents an openxr action and associated meta data
	/// </summary>
	struct SAction
	{
		// openxr action type, this is set/required in the constructor
		XrActionType xrActionType = XR_ACTION_TYPE_BOOLEAN_INPUT;

		// openxr handle for the action, this is generated by the init() call
		XrAction xrActionHandle = XR_NULL_HANDLE;

		// actionset this action is linked to, this is set from the constructor
		SActionSet *pActionSet = nullptr;

		// function will be called when the action is triggered
		Callback_InputAction pfnCallback;

		// mutex for multi-threading locks
		std::mutex mutexActionState;

		// all possible actionset forms
		union ActionState
		{
			XrActionStateBoolean stateBoolean;
			XrActionStateFloat stateFloat;
			XrActionStateVector2f stateVector2f;
			XrActionStatePose statePose;
		};

		// actionstate related to this action - this is a vector representing number of subpaths
		// if there are none, use index 0
		std::vector< ActionState > vecActionStates;

		// the subpaths for this action, empty if none
		std::vector< XrPath > vecSubactionpaths;

		// action spaces if this is a pose action - this is a vector representing number of subpaths
		// if there are none, use index 0
		std::vector< XrSpace > vecActionSpaces;

		/// <summary>
		/// Constructor - this creates an action struct with the required callback and action type
		/// no openxr action is actually generated until a call to Init() is made
		/// </summary>
		/// <param name="actionType">Type of action</param>
		/// <param name="callback">Function to call if new actionstate is available for this action</param>
		SAction( XrActionType actionType, Callback_InputAction callback )
			: xrActionType( actionType )
			, pfnCallback( callback )
		{
		}

		~SAction();

		/// <summary>
		/// Returns the availability of this action (from latest  action state)
		/// </summary>
		/// <param name="unActionStateIndex">Index for the actionstate vector representing number of subpaths, use 0 if none</param>
		/// <returns>Whether this action is active in the current input frame or not</returns>
		bool IsActive( uint32_t unActionStateIndex = 0 );
		void SetActionStateType( uint32_t unActionStateIndex = 0 );

		/// <summary>
		/// Creates an openxr action and fills in the openxr handle for this action
		/// </summary>
		/// <param name="xrInstance">The active openxr instance</param>
		/// <param name="pActionSet">Pointer to the actionset this objecti s to be linked to</param>
		/// <param name="sName">Name of the action, note do not use any special characters other than underscore</param>
		/// <param name="sLocalizedName">Localized name of the action</param>
		/// <param name="vecSubpaths">Subpaths for this action (if any - e.g. /user/hand/left)</param>
		/// <param name="pOtherInfo">Any other info via extensions</param>
		/// <returns>The result of trying to create an openxr action from the runtime</returns>
		XrResult Init( XrInstance xrInstance, SActionSet *pActionSet, std::string sName, std::string sLocalizedName, std::vector< std::string > vecSubpaths = {}, void *pOtherInfo = nullptr );

		/// <summary>
		/// Adds a subaction path (e.g. "/user/hand/left") to this action
		/// </summary>
		/// <param name="outSubactionPaths">Out parameter - XrPath(s) for hte provided string subaction paths</param>
		/// <param name="xrInstance">The active openxr instance</param>
		/// <param name="sPath">The subaction path in string form (e.g. "/user/hand/left")</param>
		/// <returns>The result of creating Xrpaths from the openxr runtime</returns>
		XrResult AddSubActionPath( std::vector< XrPath > &outSubactionPaths, XrInstance xrInstance, std::string sPath );
	};

	/// <summary>
	/// Represents an openxr actionset () and its associated meta data
	/// these are collections of actions that can be activated based on game state
	/// (e.g. one actionset for locomotion and another for ui handling)
	/// you can optionally provide a priority and other info (e.g. via extensions)
	/// </summary>
	struct SActionSet
	{
		// openxr handle generated by the runtime when calling init()
		XrActionSet xrActionSetHandle = XR_NULL_HANDLE;

		// current priority of this actionset
		uint32_t unPriority = 0;

		// actions linked ot this actionset
		std::vector< SAction * > vecActions;

		SActionSet() {}
		~SActionSet()
		{
			if ( xrActionSetHandle != XR_NULL_HANDLE )
			{
				xrDestroyActionSet( xrActionSetHandle );
			}
		}

		/// <summary>
		/// Creates an openxr actionset
		/// </summary>
		/// <param name="xrInstance">The active openxr instance</param>
		/// <param name="sName">Name of this actionset. Don't use any special characters other than an underscore</param>
		/// <param name="sLocalizedName">Localized name of this actionset - will be encoded in utf8</param>
		/// <param name="unPriority">The starting priority for this actionset. This can be changed during runtime via extensions</param>
		/// <param name="pOtherInfo">Other info when creating this actionset - optional, via extensions</param>
		/// <returns></returns>
		XrResult Init( XrInstance xrInstance, std::string sName, std::string sLocalizedName, uint32_t unPriority = 0, void *pOtherInfo = nullptr )
		{
			assert( xrInstance != XR_NULL_HANDLE );

			if ( xrActionSetHandle != XR_NULL_HANDLE )
				return XR_SUCCESS;

			XrActionSetCreateInfo xrActionSetCreateInfo { XR_TYPE_ACTION_SET_CREATE_INFO };
			xrActionSetCreateInfo.next = pOtherInfo;
			xrActionSetCreateInfo.priority = unPriority;
			std::strncpy( xrActionSetCreateInfo.actionSetName, sName.c_str(), XR_MAX_ACTION_SET_NAME_SIZE );
			std::strncpy( xrActionSetCreateInfo.localizedActionSetName, sLocalizedName.c_str(), XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE );

			XrResult xrResult = xrCreateActionSet( xrInstance, &xrActionSetCreateInfo, &xrActionSetHandle );

			if ( !XR_UNQUALIFIED_SUCCESS( xrResult ) )
			{
				LogError( "Init", "Error creating actionset %s : %s", sName.c_str(), XrEnumToString( xrResult ) );
				return xrResult;
			}

			LogInfo( "Init", "Actionset created (%s) : %s", sName.c_str(), sLocalizedName.c_str() );
			return XR_SUCCESS;
		}
	};


	/// <summary>
	/// Input handler class - encapsulates all openxr input calls and provides an easier interface to them
	/// including maintaining any necessary state and/or doing correct calls in the appropriate sequence(s)
	/// without losing any functionality or flexibility
	/// </summary>
	class CInput
	{
	  public:
		/// <summary>
		/// Constructor - pass in an active openxr instance and optional log level here
		/// </summary>
		/// <param name="pInstance">Valid and running openxr instance</param>
		/// <param name="eLoglevel">Severity level for logging</param>
		CInput( CInstance *pInstance, ELogLevel eLoglevel = ELogLevel::LogInfo );

		~CInput();

		/// <summary>
		/// Initialize input with a valid openxr session
		/// </summary>
		/// <param name="pSession">Valid openxr session - need not be runnign at this point</param>
		void Init( CSession *pSession );

		/// <summary>
		/// Convenience function to properly create an openxr actionset
		/// </summary>
		/// <param name="outActionSet">Out parameter - Pointer actionset struct</param>
		/// <param name="sName">Name of the actionset, no special characters allowed here othe than an underscore</param>
		/// <param name="sLocalizedName">Localized name of the actionset</param>
		/// <param name="unPriority">Starting priority level - may only be adjusted once running via extensions</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when trying to create an actionset with given parameters</returns>
		XrResult CreateActionSet( SActionSet *outActionSet, std::string sName, std::string sLocalizedName, uint32_t unPriority = 0, void *pOtherInfo = nullptr );

		/// <summary>
		/// Convenience function to properly create an openxr action
		/// </summary>
		/// <param name="outAction">Out parameter - pointer to an action struct</param>
		/// <param name="pActionSet">Pointer to the actionset that the new action will be linked to</param>
		/// <param name="sName">Name of the action, no special characters allowed here othe than an underscore</param>
		/// <param name="sLocalizedName">Localize name of the action</param>
		/// <param name="vecSubpaths">Optional subpaths in strign form (e.g. "user/hand/left")</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create an action with given parameters</returns>
		XrResult CreateAction( SAction *outAction, SActionSet *pActionSet, std::string sName, std::string sLocalizedName, std::vector< std::string > vecSubpaths = {}, void *pOtherInfo = nullptr );

		/// <summary>
		/// Convenience function to properly create an openxr action space (for pose actions only)
		/// </summary>
		/// <param name="outAction">Out parameter - pointer to an action struct with a pose action type</param>
		/// <param name="poseInSpace">Offset pose from base space (usually app sapce)</param>
		/// <param name="subpath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create an action space with given parameters</returns>
		XrResult CreateActionSpace( SAction *outAction, XrPosef *poseInSpace, std::string subpath = "", void *pOtherInfo = nullptr );

		/// <summary>
		/// Convenience function to automatically create openxr action spaces for pose actions with subpaths
		/// </summary>
		/// <param name="outAction">Out parameter - pointer to an action struct with a pose action type and subpaths</param>
		/// <param name="poseInSpace">Offset pose from base space (usually app sapce)</param>
		/// <param name="pOtherInfo">>Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create action spaces with given parameters</returns>
		XrResult CreateActionSpaces( SAction *outAction, XrPosef *poseInSpace, void *pOtherInfo = nullptr );

		/// <summary>
		/// Convenience function to automatically create openxr action spaces for pose actions with subpaths
		/// </summary>
		/// <param name="outAction">Out parameter - pointer to an action struct with a pose action type and subpaths</param>
		/// <param name="poseInSpaceLeft">Offset pose from base space - left (usually app space)</param>
		/// <param name="poseInSpaceRight">Offset pose from base space - right (usually app space)</param>
		/// <param name="pOtherInfo">>Optional other info via extensions</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create action spaces with given parameters</returns>
		XrResult CreateActionSpaces( SAction *outAction, XrPosef *poseInSpaceLeft, XrPosef *poseInSpaceRight, void *pOtherInfo = nullptr );

		/// <summary>
		/// Adds a binding to a controller struct
		/// </summary>
		/// <param name="controller">Out parameter - controller struct to attach the binding to, if a base controller, it will add to all "supported controllers" defined for it</param>
		/// <param name="action">The action to bind to the controller input</param>
		/// <param name="hand">Hand (left/right)</param>
		/// <param name="component">Component of the controller for this binding (e.g. thumbstick)</param>
		/// <param name="qualifier">Optional qualifier (e.g. None, click, touch)</param>
		/// <returns>Result of operation from the openxr runtime when attempting to create the binding paths for the specific controller(s)</returns>
		XrResult AddBinding( Controller *controller, XrAction action, XrHandEXT hand, Controller::Component component, Controller::Qualifier qualifier );

		/// <summary>
		/// Adds a binding to a controller struct. This allows for providign full binding paths. Note that this path is unchecked at this point, openxr runtime may reject during suggestbindings() if
		/// invalid
		/// </summary>
		/// <param name="controller">Out parameter - controller struct to attach the binding to, if a base controller, it will add to all "supported controllers" defined for it</param>
		/// <param name="action">The action to bind to the controller input</param>
		/// <param name="sFullBindingPath">Full binding path - check openxr spec and/or ext spec for the correct binding (e.g. "/user/hand/left/input/menu/click")</param>
		/// <returns>>Result of operation from the openxr runtime when attempting to create the binding paths for the specific controller(s)</returns>
		XrResult AddBinding( Controller *controller, XrAction action, std::string sFullBindingPath );

		/// <summary>
		/// Suggests all bindings added via AddBinding() to the openxr runtime
		/// </summary>
		/// <param name="controller">Pointer to controller struct representing the controller, or in the case of a base controller, all controllers supported by it</param>
		/// <param name="pOtherInfo">Optional other info via extensions</param>
		/// <returns>Result of the suggest binding operation from the runtime</returns>
		XrResult SuggestBindings( Controller *controller, void *pOtherInfo );

		/// <summary>
		/// Converts a given c++ string to an openxr path/handle
		/// </summary>
		/// <param name="string">The string to convert</param>
		/// <param name="xrPath">Out arameter - XrPath</param>
		/// <returns>Result of the conversion from the openxr runtime</returns>
		XrResult StringToXrPath( const char *string, XrPath *xrPath );

		/// <summary>
		/// Converts a valid openxr path to a c++ string
		/// </summary>
		/// <param name="outString">Out parameter - the string that will capture the conversion</param>
		/// <param name="xrPath">Valid openxr path</param>
		/// <returns>Result of the conversion from the openxr runtime</returns>
		XrResult XrPathToString( std::string &outString, XrPath *xrPath );

		/// <summary>
		/// Adds an actionset for the next input sync with the runtime
		/// </summary>
		/// <param name="pActionSet">Pointer to the actionset struct to add for the sync</param>
		/// <param name="subpath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <returns>Result of adding the actionset for sync</returns>
		XrResult AddActionsetForSync( SActionSet *pActionSet, std::string subpath = "" );

		/// <summary>
		/// Removes an actionset for the next input sync with the runtime
		/// </summary>
		/// <param name="pActionSet">Pointer to the actionset struct to remove for the sync</param>
		/// <param name="subpath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <returns>Result of removing the actionset for sync</returns>
		XrResult RemoveActionsetForSync( SActionSet *pActionSet, std::string subpath );

		/// <summary>
		/// Attaches actionsets in the session
		/// </summary>
		/// <param name="arrActionSets">Array of actionsets to attach to the openxr session</param>
		/// <param name="unActionSetCount">number of actionsets in the array</param>
		/// <returns></returns>
		XrResult AttachActionSetsToSession( XrActionSet *arrActionSets, uint32_t unActionSetCount );

		/// <summary>
		/// Processes all input and calls action callback if triggered during input frame - can be safely run in a separate thread
		/// </summary>
		/// <returns>Any result from the input check loop the runtime</returns>
		XrResult ProcessInput();

		/// <summary>
		/// Retrieves the pose for a pose action with the provided predicted display time
		/// </summary>
		/// <param name="outSpaceLocation">Output parameter - space location to hold the result</param>
		/// <param name="pAction">Pointer to an action struct of type, pose</param>
		/// <param name="unSpaceIndex">Index to vector of spaces for the pose action space representing number of subpaths, 0 if none</param>
		/// <param name="xrTime">Predicted time to check pose for</param>
		/// <returns>Result from the openxr runtime of getting the current space location of a pose action</returns>
		XrResult GetActionPose( XrSpaceLocation *outSpaceLocation, SAction *pAction, uint32_t unSpaceIndex, XrTime xrTime );

		/// <summary>
		/// Retrieves the actionstate of an action in the current input frame
		/// </summary>
		/// <param name="pAction">Pointer to an input action (any action other than haptic/vibration)</param>
		/// <returns>Result of retrieving the actionstate for the provided action from the runtime</returns>
		XrResult GetActionState( SAction *pAction );

		/// <summary>
		/// Retrieve the current active interaction profile (controller) as reported by the openxr runtime
		/// </summary>
		/// <param name="sUserPath">The user path to check (e.g. "/user/hand/left")</param>
		/// <returns>Result of check the current interaction profile (controller) from the currently active openxr runtime</returns>
		const std::string &GetCurrentInteractionProfile( const char *sUserPath );

		/// <summary>
		/// generate a haptic pulse with the frequency, duration, amplitude and frequency provided - also have common default settigns for convenience
		/// </summary>
		/// <param name="xrAction">SAction handle of a haptic openxr action</param>
		/// <param name="subPath">Optional subpath (e.g. "/user/hand/left")</param>
		/// <param name="nDuration">Duration in nanoseconds to run the haptics for</param>
		/// <param name="fAmplitude">Amplitude of the haptics between 0.0f to 1.0f</param>
		/// <param name="fFrequency">Frequency of the vibration in Hz</param>
		/// <returns></returns>
		XrResult GenerateHaptic( XrAction xrAction, XrPath subPath = XR_NULL_PATH, uint64_t nDuration = XR_MIN_HAPTIC_DURATION, float fAmplitude = 0.5f, float fFrequency = XR_FREQUENCY_UNSPECIFIED );

	  private:
		// Current severity for logging
		ELogLevel m_eMinLogLevel = ELogLevel::LogInfo;

		// Pointer to instance state from the Provider class
		CInstance *m_pInstance = nullptr;

		// Pointer to a provider session object
		CSession *m_pSession = nullptr;

		// Active action sets (XrActiveactionSet structs), this is internally kept in sync with m_vecActiveActionSets
		std::vector< XrActiveActionSet > m_vecXrActiveActionSets;

		// Active action sets (ActionSet struct pointers), this is internally kept in sync with m_vecXrActiveActionSets
		std::vector< SActionSet * > m_vecActiveActionSets;
	};

} // namespace xrlib
